import type { Document } from '../bson';
import type { Collection } from '../collection';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
<<<<<<< HEAD
import { type TimeoutContext } from '../timeout';
import { decorateWithCollation, decorateWithReadConcern } from '../utils';
import { CommandOperation, type CommandOperationOptions } from './command';
=======
import { type Callback, decorateWithCollation, decorateWithReadConcern } from '../utils';
import { CommandCallbackOperation, type CommandOperationOptions } from './command';
>>>>>>> 7e7feca6fa3c92e6242233d08162b91bde293e42
import { Aspect, defineAspects } from './operation';

/** @public */
export type DistinctOptions = CommandOperationOptions;

/**
 * Return a list of distinct values for the given key across a collection.
 * @internal
 */
<<<<<<< HEAD
export class DistinctOperation extends CommandOperation<any[]> {
=======
export class DistinctOperation extends CommandCallbackOperation<any[]> {
>>>>>>> 7e7feca6fa3c92e6242233d08162b91bde293e42
  override options: DistinctOptions;
  collection: Collection;
  /** Field of the document to find distinct values for. */
  key: string;
  /** The query for filtering the set of documents to which we apply the distinct filter. */
  query: Document;

  /**
   * Construct a Distinct operation.
   *
   * @param collection - Collection instance.
   * @param key - Field of the document to find distinct values for.
   * @param query - The query for filtering the set of documents to which we apply the distinct filter.
   * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
   */
  constructor(collection: Collection, key: string, query: Document, options?: DistinctOptions) {
    super(collection, options);

    this.options = options ?? {};
    this.collection = collection;
    this.key = key;
    this.query = query;
  }

<<<<<<< HEAD
  override get commandName() {
    return 'distinct' as const;
  }

  override async execute(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<any[]> {
=======
  override executeCallback(
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<any[]>
  ): void {
>>>>>>> 7e7feca6fa3c92e6242233d08162b91bde293e42
    const coll = this.collection;
    const key = this.key;
    const query = this.query;
    const options = this.options;

    // Distinct command
    const cmd: Document = {
      distinct: coll.collectionName,
      key: key,
      query: query
    };

    // Add maxTimeMS if defined
    if (typeof options.maxTimeMS === 'number') {
      cmd.maxTimeMS = options.maxTimeMS;
    }

    // we check for undefined specifically here to allow falsy values
    // eslint-disable-next-line no-restricted-syntax
    if (typeof options.comment !== 'undefined') {
      cmd.comment = options.comment;
    }

    // Do we have a readConcern specified
    decorateWithReadConcern(cmd, coll, options);

    // Have we specified collation
<<<<<<< HEAD
    decorateWithCollation(cmd, coll, options);

    const result = await super.executeCommand(server, session, cmd, timeoutContext);

    return this.explain ? result : result.values;
=======
    try {
      decorateWithCollation(cmd, coll, options);
    } catch (err) {
      return callback(err);
    }

    super.executeCommandCallback(server, session, cmd, (err, result) => {
      if (err) {
        callback(err);
        return;
      }

      callback(undefined, this.explain ? result : result.values);
    });
>>>>>>> 7e7feca6fa3c92e6242233d08162b91bde293e42
  }
}

defineAspects(DistinctOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE, Aspect.EXPLAINABLE]);
